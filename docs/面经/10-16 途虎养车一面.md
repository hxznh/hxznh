估计要挂，金融方向的，难度比较高，加上好久没面这方面的内容，八股文忘了不少

==！表示没答好的问题==



1. 手撕代码  判断给定的括号序列是否合法（只有小括号）

2. java基本类型和包装类型的区别 **！**

   答了一个是对象引用的形式，一个是值的形式。

   默认值包装类型是**null**（面试答错了，答的都是0），**基本类型是0**

   > 正解

   ```java
   1、包装类是对象，拥有方法和字段，对象的调用都是通过引用对象的地址；基本类型不是 
   2、包装类型是引用的传递；基本类型是值的传递 
   3、声明方式不同：
                   基本数据类型不需要new关键字；
                   包装类型需要new在堆内存中进行new来分配内存空间 
   4、存储位置不同：
                   基本数据类型直接将值保存在值栈中；
                   包装类型是把对象放在堆中，然后通过对象的引用来调用他们 
   5、初始值不同：
                   int的初始值为 0 、 boolean的初始值为false 
                   包装类型的初始值为null 
   6、使用方式不同：
                   基本数据类型直接赋值使用就好；
                   包装类型一般可以放在集合中使用，如 Collection集合中List、Set，以及Map键值对存储。
   ```

3. 拆箱和装箱的原理 **!**

   只说了装箱是调用valueOf方法，不会拆箱原理。

   > 正解

   装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。

   举个例子：

   Java 代码

   ```java
   public class Main {
       public static void main(String[] args) {
           Integer integer1 = 10;
           int int1 = integer1;
           int int2 = 10;
           Integer integer2 = int2;
       }
   }
   ```

   编译后通过 javap -c 查看对应Main.class文件

   ```
   public class src.java.Main {
     public src.java.Main();
       Code:
          0: aload_0
          1: invokespecial #1                  // Method java/lang/Object."<init>":()V
          4: return
   
     public static void main(java.lang.String[]);
       Code:
          0: bipush        10
          6: aload_1
          7: invokevirtual #13                 // Method java/lang/Integer.intValue:()I
         10: istore_2
         11: bipush        10
         13: istore_3
         14: iload_3
         15: invokestatic  #7                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
         18: astore        4
         20: return
   }
   ```

   可以看到，在装箱时通过`Integer.valueOf()`方法进行装箱，拆箱时通过`Integer.intValue()`进行拆箱

4. Java中垃圾回收算法

   标记清除，标记整理，标记复制

5. 以及如何判断对象可以被回收

   GC ROOT 可达性分析，讲了常量和静态变量持有的引用对象。

   引用计数法无法处理循环依赖问题

6. 老年代和新生代分别使用什么样的回收算法。

   一开始没反应过来问啥，感觉应该根据不同的收集器来决定。

   想了一下讲了新生代有幸存者1 2区，应该是标记复制

   老年代是标记整理，因为老年代都是长期持有的或者是大对象，减少内存碎片，提高利用率。

7. 什么场景使用多线程？线程数怎么确定  **!**

   不是很会。

   最大线程数最好是CPU核数*2+1的样子，充分利用cpu的线程。

   场景，举了IO处理，大任务拆分计算。

8. 如何选择线程池的拒绝策略。  **!**

   只记得丢弃，交由提交任务的线程处理，丢弃最早的任务。

   还有一个常用的是抛异常来拒绝，或者实现`RejectedExecutionHandler`接口来自定义策略

   怎么选择，不会。

   > 网上答案

   大致可以根据以下几个因素

   * 任务处理的优先级：如果任务的实时性较高，可能需要选择能够立即执行任务的策略，如CallerRunsPolicy。
   * 任务的重要性：如果任务的重要性较高，可以选择将新任务加入工作队列而不执行当前任务的策略，如DiscardOldestPolicy。
   * 需要灵活的处理：抛异常拒绝

9. 简单介绍常用数据结构，数组、链表、队列、栈

10. 说一个时间复杂度$O(n^2)$和$O(nlogn)$的算法

    冒泡、归并

11. 归并的时间复杂度怎么nlogn得出的

    递归logn层，每层遍历n次

12. 二叉树有几种存储形式

    链表，每个结点存左右子节点

    数组，左右子节点编号是父节点 * 2 和 * 2 +1

13. 哪种二叉树更适合用数组存储

    完全/满二叉树用数组比较好。用数组比较能够充分利用空间

    稀疏的树用链表形式，节省空间

14. 除去刚才说的数据结构，再说两个数据结构。

    (这个问题很没水平)

    嗯一开始没懂啥意思，说了个b+树，他说要不说树这个形态了，说点别的。

    我就没想出来还有啥结构了。

    面试官说比如散列表

    那我就补了个，那邻接表算吗

    也彳亍。

    

    个人感觉这个问题问的很不好。各种意义上，邻接表和散列表也是数组或者链表来实现的。

15. 十个sql关键字

    这个问题也很没水平。

16. 5种sql语句优化

    不要where中对条件计算。

    in中嵌套查询尽可能结果集小一点。

    不要select *

    不会了。

    > 面经里记的

    ```java
    * 少使用select * ，尽量使用具体字段
    * 对于条件来说等号两边的字段类型要一致，字符串不加单引号索引会失效
    * 尽量少使用order by排序，对于需要多个字段进行排序的可以使用组合索引
    * 对于group by语句要先过滤，后分组
    * 在查询是减少使用null，对字段有多个null值可以添加默认值
    * 少使用like，对于必须要使用的，尽量使用 like abc% 这种，不要把%放在前面
    * 在where后面少使用函数或者算数运算
    * 去除的distinct过滤字段要少，避免distinct *
    * 不要超过5个以上的表连接
    ```

    

17. 再说两个索引失效的场景

    字段隐式转换

    不符合索引最左匹配原则

18. tcp五层模型

    <img src="https://cdn.jsdelivr.net/gh/hxznh/images@main/image-20220809235921096.png" alt="image-20220809235921096" style="zoom: 50%;" />

19. 三次握手四次挥手

    <img src="https://cdn.jsdelivr.net/gh/hxznh/images@main/image-20221002221003482.png" alt="image-20221002221003482" style="zoom: 33%;" />

    <img src="https://cdn.jsdelivr.net/gh/hxznh/images@main/image-20221002222322797.png" alt="image-20221002222322797" style="zoom: 33%;" />

20. 三个常用设计模式含义，以及java中的使用场景。

    单例，bean创建默认单例

    工厂，面的时候忘了beanFactory这个东西了

    装饰器模式，Buffered Input/Output Stream

    建造者模式，本来想的是之前mybatis的插件，但是这个好像比较冷门，不知道其他地方哪里用了，不该讲。

    （补充：mybatis-plus有建造者模式）

    动态代理：SpringAOP

    ---

    讲项目了

    按准备好的经历来讲就好

21. 消息模块解耦的场景？

    多个消息发送功能。

22. 怎么保证消息可靠投递

    rabbitmq的ack功能。消费完手动ack即可。

23. 怎么保证消息不重复消费。

    （没实际做，背八股文环节）

    通过唯一id，比如用户id+时间+sessionid拼接（挖坑了），消费前去redis查询。没有就是没消费，消费完set进redis。

24. sessionid怎么生成的？  **！**

    不会，代码骨架内部做好了

25. 自己设计的话怎么设计唯一id？可以抛弃现有实现方式

    并发比较小可以直接通过mysql主键

    uuid也彳亍

    并发大的话可以雪花算法。

26. 那，多个结点部署的情况下，有考虑过机器码怎么唯一吗？ **!**

    说的感觉可以配置好写死，没实际操作过。

27. 有考虑过消息顺序性怎么保证？  **!**

    这个八股文忘了，没背上来。直接说没考虑过。

28. 实习项目用Redis的缓存的key是什么样的？

    用户id、菌株id

29. 怎么保证缓存一致性？

    修改时加锁，删缓存

30. 先更新再淘汰缓存对吧？

    对，也可以先删再更新，说业务中特别短暂的不一致是允许的。

    

> 反问环节

1. 主要业务？

   交易供应链+结算。生成即时账单。数据量级+时效性要求很高

2. 主要技术栈？

   java，有独立的中间件团队维护组件。业务团队主要面向业务的实现。














































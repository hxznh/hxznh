1.  [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

2.  给定一个数组，找出其中可以组成有效三角形的数字组合有多少种

```java
// 输入 [2,2,2,3]
// 输出 4
// [2,2,2], [2,2,3], [2,2,3], [2,2,3]
```

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型一维数组 
     * @return int整型
     */
    public int validTriangle (int[] nums) {
        int res = 0;
        Arrays.sort(nums);
        int n = nums.length;
        for (int i = 0; i < n - 2; i++) {
            for (int j = i + 1; j < n - 1; j++) { 
                int target = nums[i] + nums[j];
                for (int k = j + 1; k < n; k++) {
                    if (nums[k] >= target) {
                        break;
                    }
                    res++;
                }

            }
        }

        return res;
    }
}

```







在某虎公司中，某虎售卖轮胎的规格是由三部分组出的分别为胎宽tw扁平比ta、轮毂直径tr。

轮胎的标准规格一般表为{tw}/{ta}R{tr}. 比如: 225/55R17表示胎宽为225、扁平比为55轮毂直径为17。

但是在用户的查询过程中，由于输入习惯或者输入错误等原因，输入的轮胎规格可能并非标准
已知:
1，规格必须按照胎宽tw、扁平比ta、轮毂直径tr顺序排列。
2，用户输入的胎宽tw、扁平比ta之间可能存在0-1位分割符，分隔符不为数字、字母。
3，用户输入的扁平比ta、轮毂直径tr之间可能存在0-1位分隔符，分隔符不为数字， 且分割符不为除了R和r之外的字母。

现给定一系列的胎宽tw、扁平比ta、轮毂直径tr参数,以及用户的查询query词，返回查询词和查询中的标准规格。
如果存在多个标准规格，则需要输出多个规格以逗号分割,多个规格之间无需去重;如果不存在标准规格，则输出字符串"null"。



> 样例

```java
// 输入
[225,235,245, 255],[40,45,50,55,60],[15,16, 17,18,19],"轮胎225/55r17"
// 输出
["225/55R17"]

// 输入
[225,235,245,255],[40,45,50，55,60],[15.16,17,18,19],"马牌22555r16 马牌22555r17"
// 输出
[225/55R16","225/55R17"]

// 输入
[225,235,245,255],[40,45,50,55,60],[15,16,17,18,19],"马牌22555r16，固特异22555r16"
// 输出
[225/55R16","225/55R16"]
```



45%不到

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 返回标准规格list
     * @param tw int整型一维数组 轮胎胎宽
     * @param ta int整型一维数组 轮胎扁平比
     * @param tr int整型一维数组 轮胎直径
     * @param query string字符串 查询query
     * @return string字符串ArrayList
     */
    public ArrayList<String> fetchTireSize (int[] tw, int[] ta, int[] tr, String query) {
        System.out.println(query);
        Set<Integer> twS = new HashSet<>();
        Set<Integer> taS = new HashSet<>();
        Set<Integer> trS = new HashSet<>();
        for (int x: tw) {
            twS.add(x);
        }
        for (int x: ta) {
            taS.add(x);
        }
        for (int x: tr) {
            trS.add(x);
        }
        ArrayList<String> list = new ArrayList<>();
        int n = query.length();
        for (int idx = 0; idx < n; idx++) {
            while (idx < n && !Character.isDigit(query.charAt(idx))) {
                idx++;
                continue;
            }
            boolean flag = true;
            boolean fta = false, ftw = false, ftr = false;

            int i = idx;
            int utw = -1;
            if (n - i >= 3 &&
                Character.isDigit(query.charAt(i + 1)) &&
                Character.isDigit(query.charAt(i + 2))
            ) {
                utw = Integer.parseInt(query.substring(i, i + 3));
            }
            if (twS.contains(utw)) {
                ftw = true;    
            }
            i += 3;
            while (i < n && !Character.isDigit(query.charAt(i))) {
                i++;
            }
            
            int uta = -1;
            if (n - i >= 2 &&
                Character.isDigit(query.charAt(i + 1))) {

                uta = Integer.parseInt(query.substring(i, i + 2));
            }
            if (taS.contains(uta)) {
                fta = true;    
            }
            i += 2;
            while (i < n && !Character.isDigit(query.charAt(i))) {
                i++;
            }

            int utr = -1;
            if (n - i >= 2 && 
                Character.isDigit(query.charAt(i + 1))) {
                
                utr = Integer.parseInt(query.substring(i, i + 2));
            }
            if (trS.contains(utr)) {
                ftr = true;    
            }
            i += 2;
            if (fta && ftr && ftw) {
                list.add(new String(utw + "/" + uta + "R" + utr));
                // System.out.println(utw + " " + uta + " " + utr);
            } else {
                list.add("null");
            }
            idx = i - 1;
        }
        
        return list;
    }
}

```

